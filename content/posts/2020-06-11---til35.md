---
title: Database 기초
date: "2020-06-11T13:57:32.169Z"
template: "post"
draft: false
slug: "til35"
category: "database"
tags:
  - "til"
  - "database"
  - "sql"
  - "wecode"
description: "데이터베이스가 무엇인지, 데이터베이스의 성질에는 어떤 것이 있는지 알아본다."
socialImage: "/naon.png"
---

### 데이터베이스란?
데이터베이스란 데이터 저장/편집/가공/보존을 편리하게 해주는 시스템이다. 해당 애플리케이션을 종료하면 데이터가 휘발되는 메모리와는 반대 성질을 가지고 있다. 메모리는 속도가 빠르기 때문에 저장은 데이터베이스에, 작업은 메모리에서 한다.

### 관계형 데이터베이스 시스템(RDBMS, Relation DataBase Management System)
데이터를 상호관련성을 가진 형태로 표현한 데이터베이스 시스템이다. 상호관련성이란, 서로 연결지을 수 있다는 것을 뜻한다. 모든 데이터는 2차원 테이블로 표현되며, 각 테이블은 열(column)과 행(row)으로 구성된다. 아래 예시처럼 열에는 필드명이 들어가며 행에는 실제 값이 들어간다.

| users |
|:---|
| id |
| email |
| password |

각 테이블은 상호관련성을 가지고 서로 연결할 수 있다. 이때 각 테이블의 고유 키(Primary Key)로 연결한다. 테이블 연결 방식은 **one to one**, **one to many**, **many to many** 로 나눌 수 있는데 이해를 쉽게 하기 위해 아래 이미지를 보자.

- one to one 방식
![table oto](/media/db-oto.png)
users는 유저가 가입 시 필수로 입력해야 하는 정보를 담은 테이블이라고 하고, 부가로 입력해야 하는 정보를 user_profile에 담았다고 가정해보자. 필수 정보든 부가 정보든 모든 유저는 하나의 프로필을 갖는다. 따라서 이 두 테이블을 연결하면 one to one 연결이 된다. 유저 A의 부가 정보는 유저 A 프로필에만 해당하는 내용이기 때문이다.

<br>

- one to many 방식
![table otm](/media/db-otm.png)
customers는 유저 이름을 담은 테이블이라고 하고, orders는 그 유저의 주문 정보를 담은 테이블이라고 하자. 모든 주문 정보는 고유하며, 같은 물건을 주문했다고 하더라도 유저를 구분해서 연결해야 한다. 한 유저가 여러 건의 주문을 할 수 있으므로 유저 하나에 여러 주문 정보 테이블을 연결할 수 있다. 이것을 one to many 방식이라 한다.

<br>

- many to many 방식
![table mtm](/media/db-mtm.png)
소설 단편집을 여러 권 출판한 작가진이 있다고 가정해보자. 책 A 작가진 A, B, C, D가 있다고 가정하면 책 A는 작가 A, B, C, D 모두와 연결된다. 먼저 작가 테이블을 생성하고, 책 테이블을 생성한다. 그 다음에 작가와 책 테이블을 이어줄 매개인 책 A 테이블을 생성해서 작가 테이블, 책 테이블과 연결한다. 한 작가가 여러 책을 쓸 수 있고, 책 또한 여러 작가에 의해 쓰일 수 있다. 이것이 many to many 방식이다 연결고리가 되는 중간 테이블명은 보통 `첫 번째 테이블명_두 번째 테이블명`으로 짓는다.

위 이미지에서 Primary key의 역할 또한 알 수 있는데, 한 테이블에 `연결할 다른 테이블명_연결할 다른 테이블의 PK명`을 입력해주고 연결할 테이블에서 필드에 해당하는 값을 찾아서 써주면 된다. 이것이 Foreign key 개념을 이용해 테이블을 연결하는 방식이다.

<br>

### 데이터베이스의 성질
- 원자성(Atomicity)
- 일관성(Consistency)
- 고립성(Isolation)
- 지속성(Durability)

이것을 **ACID**라고 한다.
데이터베이스의 성질을 뜯어보기 전에 **트랜잭션**이라는 용어를 짚고 넘어가자. 트랜잭션이란 요청이 수행되거나 수행되지 않는 하나의 작업 단위다. 즉 요청을 완수하고 작업을 끝내든, 오류가 나서 완수하지 못하고 끝내든 관계 없이 작업이 끝난다면 그 하나의 작업을 트랜잭션이라고 한다. 데이터베이스 관리 시스템(DMS) 성능은 초당 트랜잭션 실행 수(fps)로 측정한다.

#### 원자성(Atomicity)
All or nothing. 작업을 완수하거나 아예 완수하지 못하거나. 트랜잭션이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 은행 어플에서 송금을 하던 중 오류가 발생했다고 가정해보자. 내 통장에서 출금은 됐지만 상대 통장에는 입금되지 않고 중간에 작업이 끊겨버리면 안 된다. 내 통장에서 출금이 됐다면 상대 통장에 입금이 되어야 하고(요청한 작업 완수), 만약 송금 오류가 난다면 내 통장에서 돈이 빠져나간 걸 롤백으로 돌려놓고 작업이 종료되어야 한다(요청한 작업 완수하지 못했지만 트랜잭션 종료).

#### 일관성(Consistency)
데이터 타입, 상태가 언제나 같은 상태로 유지되는 것을 말한다.

#### 고립성(Isolation)
다른 트랜잭션의 연산 작업에 끼어들지 못하도록 보장하는 것을 말한다. 트랜잭션 밖에 있는 어떠한 연산도 중간 단계의 데이터를 볼 수 없다.

#### 지속성(Durability)
성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것을 말한다. 시스템 장애 발생 전 상태로 되돌리더라도, 모든 트랜잭션은 로그로 남는다.

<br>

### SQL(RDBMS) vs NoSQL
#### SQL이란?
SQL은 데이터간 관계성을 고려하고 저장하기 때문에 데이터를 체계적으로 관리할 수 있다. 따라서 정형화된 데이터, 그리고 데이터의 완전성이 중요한 데이터를 저장하는 데에 유리하다. 하지만 데이터를 저장하기 전 테이블을 미리 정의해야 하므로 테이블 구조 변화에 발빠르게 대응할 수 없다. 같은 맥락에서 확장성이 떨어진다.

#### SQL로 저장하면 좋은 데이터
전자상거래 정보, 은행 계좌 정보, 거래 정보 등

#### NoSQL이란?
NoSQL은 SQL과 반대되는 개념이다. 테이블 구조를 미리 정의하지 않아도 되므로 데이터 구조 변화에 유연하게 대처할 수 있다. 확장하기가 쉽기 때문에 방대한 양의 데이터를 저장하는 데에 유리하다. 하지만 데이터 완전성이 덜 보장되며 트랜잭션이 안 되거나 불안정하다.

#### NoSQL로 저장하면 좋은 데이터
로그 데이터