{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/til85","result":{"data":{"markdownRemark":{"id":"4caa6ba7-b53e-5a5c-986b-33d6dcc58bac","html":"<h3 id=\"7장-ip-프로토콜의-이해\" style=\"position:relative;\"><a href=\"#7%EC%9E%A5-ip-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C%EC%9D%98-%EC%9D%B4%ED%95%B4\" aria-label=\"7장 ip 프로토콜의 이해 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>7장. IP 프로토콜의 이해</h3>\n<h4 id=\"2-라우팅\" style=\"position:relative;\"><a href=\"#2-%EB%9D%BC%EC%9A%B0%ED%8C%85\" aria-label=\"2 라우팅 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>(2) 라우팅</h4>\n<h4 id=\"강의-목표\" style=\"position:relative;\"><a href=\"#%EA%B0%95%EC%9D%98-%EB%AA%A9%ED%91%9C\" aria-label=\"강의 목표 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>강의 목표</h4>\n<ul>\n<li>\n<p>라우팅 기능과 주요 프로토콜 이해</p>\n<ul>\n<li>간단한 라우팅 프로토콜</li>\n<li>거리-벡터 프로토콜</li>\n<li>링크 상태 프로토콜</li>\n<li>외부 라우팅 프로토콜</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"간단한-라우팅-프로토콜\" style=\"position:relative;\"><a href=\"#%EA%B0%84%EB%8B%A8%ED%95%9C-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"간단한 라우팅 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>간단한 라우팅 프로토콜</h4>\n<ul>\n<li>\n<p>최단 경로 라우팅\n<img src=\"/media/network32.png\" alt=\"최단 경로 라우팅\"></p>\n<ul>\n<li>거리 기준은 다양하지만 <strong>중간에 거치는 홉(hop) 수로 판단</strong></li>\n<li><strong>패킷이 목적지로 가는 동안 거치는 라우터 수가 최소가 되도록 경로를 선택</strong></li>\n<li>a -> d로 가려면 a-b-d 경로 선택, a -> g로 가려면 a-c-g 경로 선택</li>\n<li>\n<p>기타 거리 기준</p>\n<ul>\n<li>패킷의 전송 지연, 전송 대역폭, 통신 비용 등</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>플러딩(Flooding)</p>\n<ul>\n<li>입력된 패킷을 라우터가 <strong>출력 가능한 모든 경로로 중개</strong>하는 방식</li>\n<li>확실하게 전달할 수 있다는 장점이 있지만 네트워크에 <strong>패킷이 무한 개 만들어질 위험</strong>이 있음</li>\n<li>홉 수를 일정 범위로 제한하고 제거하는 방식으로 대처 가능</li>\n<li><strong>중요한 데이터를 모든 호스트에게 동시에 전달하는 환경에서 제한적으로 사용</strong></li>\n</ul>\n</li>\n</ul>\n<h4 id=\"거리-벡터-프로토콜\" style=\"position:relative;\"><a href=\"#%EA%B1%B0%EB%A6%AC-%EB%B2%A1%ED%84%B0-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"거리 벡터 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>거리-벡터 프로토콜</h4>\n<ul>\n<li>라우터 <strong>자신과 직접 연결된 주변 라우터</strong>에게 라우팅 정보를 교환하는 방식</li>\n<li><strong>자기가 가지고 있는 전체 네트워크에 대한 지식</strong>을 <strong>이웃 라우터에게만 일정한 주기로</strong> 전달</li>\n<li>전달하는 정보는 <strong>개별 네트워크까지 걸리는 거리 정보</strong></li>\n<li>\n<p>따라서 개별 라우터에서는 아래 정보를 필수로 유지해야함</p>\n<ul>\n<li><strong>링크 벡터</strong>: 직접 연결된 네트워크에 대한 연결 정보</li>\n<li><strong>거리 벡터</strong>: 전체 개별 네트워크에 대한 거리 정보</li>\n<li><strong>다음 홉 벡터</strong>: 개별 네트워크로 가기 위한 다음 홉 정보</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/network33.png\" alt=\"네트워크 구성 예\"></p>\n<ul>\n<li>\n<p>링크 벡터 - 특정 네트워크로 직접 갈 수 있는 포트번호</p>\n<ul>\n<li>L(x) = [포트(1), 포트(2), … , 포트(M)]</li>\n<li>L(R1) = [1, 3, -, -, -]</li>\n<li>L(R2) = [1, -, -, 8, -]</li>\n<li>L(R3) = [-, 2, -, 6, -]</li>\n</ul>\n</li>\n<li>\n<p>거리 벡터 - 각 네트워크를 얼마만큼 거리로 도달할 수 있는지</p>\n<ul>\n<li>D(x) = [거리(1), 거리(2), … , 거리(N)]</li>\n<li>D(R1) = [1, 1, 2, 2, 2]</li>\n<li>D(R2) = [1, 2, 2, 1, 2]</li>\n<li>D(R3) = [2, 1, 2, 1, 2]</li>\n</ul>\n</li>\n<li>\n<p>다음 홉 벡터 - 각 네트워크로 가려면 어떤 라우터를 거쳐야 하는지</p>\n<ul>\n<li>H(x) = [홉(1), 홉(2), … , 홉(N)]</li>\n<li>H(R1) = [-, -, R4, R3, R6]</li>\n<li>H(R2) = [-, R1, R5, -, R8]</li>\n</ul>\n</li>\n<li>\n<p>RIP(Routing Information Protocol)</p>\n<ul>\n<li>거리-벡터 방식</li>\n<li>소규모 네트워크 환경에 적합</li>\n<li>주변 라우터가 제공하는 거리 벡터 정보가 임의의 짧은 시간 내에 모두 도착해야 하는데 이는 현실적으로 어려움 (UDP 사용 - 패킷 손실 가능성 있음)</li>\n<li>\n<p>라우팅 정보를 수정하는 경우</p>\n<ul>\n<li>거리 벡터 정보가 새로운 네트워크 주소면 적용</li>\n<li>목적지까지 더 짧으면 기존 경로를 대체</li>\n<li>거리 벡터 정보가 입력되면 등록 정보를 수정</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/network35.png\" alt=\"네트워크 구성 예\">\n<img src=\"/media/network34.png\" alt=\"수정 전 라우팅 테이블\"></p>\n<ul>\n<li>\n<p>임의의 시점에 다음 정보 도착</p>\n<ul>\n<li>R2 = [1. 2. 2. <strong>1</strong>. 2]</li>\n<li>R3 = [2, 1, 2, <strong>1</strong>, 2]</li>\n<li>R4 = [2, 1, 1, 2, 2]</li>\n<li>R5 = [2, 1, 2, 2, 1]</li>\n</ul>\n</li>\n<li>\n<p>각 라우터까지 거리 + 도착한 값과 기존 값 비교</p>\n<ul>\n<li>R2까지 거리 1 + 도착한 값 1 &#x3C; Net.4까지의 기존 거리 3</li>\n<li>R3까지 거리 1 + 도착한 값 1 &#x3C; Net.4까지의 기존 거리 3</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/network36.png\" alt=\"수정 후 네트워크 구성과 라우팅 테이블\"></p>\n<ul>\n<li>RIP 패킷 구조\n<img src=\"/media/network37.png\" alt=\"RIP 패킷\"></li>\n<li>\n<p>Command</p>\n<ul>\n<li>1이면 요구, 0이면 응답</li>\n<li>초기에 요구를 받으면 즉시 응답해야 함</li>\n</ul>\n</li>\n<li>\n<p>IP Address</p>\n<ul>\n<li>네트워크 지칭 (0으로 끝남)</li>\n</ul>\n</li>\n<li>\n<p>Metric</p>\n<ul>\n<li>목적지 네트워크까지 홉 수</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"링크-상태-프로토콜\" style=\"position:relative;\"><a href=\"#%EB%A7%81%ED%81%AC-%EC%83%81%ED%83%9C-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"링크 상태 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>링크 상태 프로토콜</h4>\n<ul>\n<li>\n<p>거리-벡터 프로토콜의 단점 개선</p>\n<ul>\n<li>주변 상황에 변화가 있을 때 <strong>주변 라우터까지의 정보</strong>를 <strong>모든 라우터에 전달</strong></li>\n</ul>\n</li>\n<li><strong>모든</strong> 라우터에 전달해야 하기 때문에 플러딩 방식을 사용해 받은 쪽을 제외한 나머지 라우터에 모두 전달</li>\n<li>링크 상태 프로토콜의 대표 예시는 <strong>OSPF(Open Shortest Path First) 프로토콜</strong></li>\n</ul>\n<h5 id=\"ospf-토폴로지\" style=\"position:relative;\"><a href=\"#ospf-%ED%86%A0%ED%8F%B4%EB%A1%9C%EC%A7%80\" aria-label=\"ospf 토폴로지 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>OSPF 토폴로지</h5>\n<p><img src=\"/media/network38.png\" alt=\"OSPF 토폴로지\"></p>\n<ul>\n<li>5개의 OSPF 라우터(R1~R5) 존재</li>\n<li>라우터간 연결 링크에 대한 IP 주소(<em>예 - R1과 R2 사이 1.1.1.0/30</em>)와 OSPF Cost(<em>예 - R1과 R2 사이 (10)</em>) 및 각 라우터의 Loopback 주소(*예 - R1의 10.1.0.1) 표시</li>\n<li>파란색 줄(링크)가 OSPF가 enable임을 표시</li>\n</ul>\n<p>각 라우터가 링크 정보를 전파하는 방식과 순서</p>\n<ul>\n<li>\n<p>R1\n<img src=\"/media/network39.png\"></p>\n<ul>\n<li>‘R1은 R2, R3에 연결되어 있다’는 링크 정보를 다른 라우터에게 전달하려면,</li>\n<li>R1에 연결된 모든 라우터(R2, R3)에 정보 전달</li>\n<li>R2는 정보를 받은 R1을 제외하고 R4, R5에 전달</li>\n<li>R3도 R1을 제외하고 연결된 R4, R5에 전달</li>\n<li>\n<p>R4, R5는 동일한 Router-LSA를 2개씩 수신</p>\n<ul>\n<li>LSA 식별자에 해당하는 LS Type, Link State ID, Advertising Router가 동일한 경우 <strong>나중에 수신한 LSA를 폐기</strong></li>\n<li>여기에서는 R2로부터 온 정보가 더 먼저 도착했기 때문에(Cost가 10으로 Cost가 20인 R3보다 빠름) R3로부터 받은 정보는 폐기함</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p>R2\n<img src=\"/media/network40.png\"></p>\n<ul>\n<li>자신의 링크 정보를 다른 OSPF 라우터로 전파</li>\n<li>이를 수신한 R1, R4, R5는 Router-LSA가 수신된 링크를 제외한 나머지 링크로 플러딩</li>\n<li>R3은 동일한 Router-LSA를 3개 수신</li>\n<li>가장 먼저 수신한 것(R1으로부터)을 제외한 나머지 폐기</li>\n</ul>\n</li>\n<li>R3\n<img src=\"/media/network41.png\"></li>\n<li>R4\n<img src=\"/media/network42.png\"></li>\n<li>R5\n<img src=\"/media/network43.png\"></li>\n</ul>\n<p>모든 정보를 모아서 전체 그림을 그림\n<img src=\"/media/network44.png\"></p>\n<p>최단 경로(=cost가 가장 적은) 트리 구성\n<img src=\"/media/network45.png\">\n<img src=\"/media/network46.png\"></p>\n<h4 id=\"외부-라우팅-프로토콜\" style=\"position:relative;\"><a href=\"#%EC%99%B8%EB%B6%80-%EB%9D%BC%EC%9A%B0%ED%8C%85-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C\" aria-label=\"외부 라우팅 프로토콜 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>외부 라우팅 프로토콜</h4>\n<ul>\n<li>외부 라우팅 프로토콜에서 사용하는 경로 벡터는 경로에 관한 거리 정보값이 필요 없는 방식</li>\n<li>어디를 통해서 연결되는지, 연결 여부가 더 중요</li>\n<li>내부 라우팅 프로토콜과는 달리 거리(비용)에 대한 처리 과정이 없음</li>\n<li>목적지 네트워크에 도착하기 위한 <strong>자율시스템에 대한 내용만 포함</strong></li>\n<li>\n<p>BGP(Border Gateway Protocol)</p>\n<ul>\n<li>인터넷에서 많이 사용</li>\n<li>서로 다른 종류의 자율시스템간 정보 교환 가능</li>\n<li>TCP를 이용하여 정보 교환</li>\n<li>\n<p>메시지 종류</p>\n<ul>\n<li>Open: 관계 생성</li>\n<li>Updata: 경로 관련 정보 전달</li>\n<li>KeepAlive: Open에 대한 응답 기능과 주기적인 관계 확인 기능</li>\n<li>Notification: 오류 상태 통보</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h5 id=\"bgp\" style=\"position:relative;\"><a href=\"#bgp\" aria-label=\"bgp permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>BGP</h5>\n<ul>\n<li>평면적 라우팅은 확장이 어려움. (저장 공간, 합의에 도달하는 시간, 통신 문제 등)</li>\n<li>목적지에 이르는 거리가 멀수록 더 적은 정보를 이용하는 것이 타당</li>\n<li>해결 방안: <strong>영역 계층구조(Area Hierarchy)</strong></li>\n</ul>\n<p><img src=\"/media/network47.png\" alt=\"BGP 구조\"></p>\n<ul>\n<li><strong>망을 영역으로 분할</strong></li>\n<li>각 영역에 서브 영역 존재 가능</li>\n<li>망 노드는 계층적 주소 부여</li>\n<li>\n<p>영역 내부</p>\n<ul>\n<li><strong>각 노드는 다른 노드로 가는 경로 보유</strong></li>\n</ul>\n</li>\n<li>\n<p>영역 외부</p>\n<ul>\n<li>각 노드는 <strong>다른 top-level 영역으로 가는 경로만 보유</strong></li>\n<li>영역간 패킷은 적절한 border router에게 전달</li>\n</ul>\n</li>\n</ul>\n<p><img src=\"/media/network48.png\" alt=\"BGP 구조 예시\"></p>\n<ul>\n<li>실제로 더 짧은 경로가 있음에도 영역 외부에서는 각 영역 top level끼리만 오갈 수 있기 때문에 비효율적일 수 있음</li>\n<li>하지만 단순하게 구성 가능</li>\n</ul>\n<p><strong>자율시스템(AS: Autonomous System)</strong></p>\n<ul>\n<li>하나의 기술적 관리 하에 있는 라우터들의 집합</li>\n<li>AS 안에서는 IGP(Interior Gateway Protocol)와 패킷을 전달하기 위한 <strong>공통 메트릭 이용</strong></li>\n<li>다른 AS로 전달하기 위해서는 EGP(Exterior ~) 사용</li>\n<li>가끔 하나의 AS 안에서 여러 IGP를 이용할 수도 있지만, 외부에는 하나의 AS로만 인식됨</li>\n<li>\n<p>각 AS는 유일한 ID 할당</p>\n<ul>\n<li>16비트로 구성</li>\n<li>64512 ~ 65535는 private ID</li>\n<li>\n<p>예</p>\n<ul>\n<li>MIT: 3</li>\n<li>JANET: 786</li>\n<li>AT&#x26;T: 7018, 6341, 5074</li>\n<li>Sprint: 1239, 1240, 6211, 6242</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>AS는 피어 역할</li>\n</ul>\n<p><img src=\"/media/network50.png\" alt=\"AS 구조\"></p>\n<p><strong>Logical view of the internet</strong>\n<img src=\"/media/network49.png\" alt=\"인터넷의 이론적 모습\"></p>\n<ul>\n<li>실제로는 이렇지 않음! (엔드 호스트가 라우터에 연결되는 방식 X)</li>\n<li>RIP, OSPF는 계층적 구조가 아니기 때문에 확장성이 떨어진다 -> 사실이 아님</li>\n<li>ISP에도 계층이 존재함\n<img src=\"/media/network51.png\" alt=\"티어가 존재하는 ISP\"></li>\n<li>Tier1 ISP는 전역(global)적으로 도달 가능</li>\n<li>Tier2,3은 local</li>\n</ul>\n<p><strong>Transit vs. Peering</strong>\n<img src=\"/media/network52.png\" alt=\"티어가 존재하는 ISP\"></p>\n<ul>\n<li>Transit은 더 큰 ISP와 묶이는 것</li>\n<li>Peering은 규모가 비슷한 ISP끼리 묶이는 것</li>\n</ul>\n<p><strong>그렇다면</strong></p>\n<ul>\n<li>\n<p>링크 상태 vs. 거리-벡터 프로토콜 중 무엇을 쓸 것인가?</p>\n<ul>\n<li>정답은 없음. 상황과 정책에 따라 판단</li>\n</ul>\n</li>\n<li>\n<p>거리-벡터 문제점</p>\n<ul>\n<li>수렴하지 않을 가능성</li>\n</ul>\n</li>\n<li>\n<p>링크 상태 문제점</p>\n<ul>\n<li>전체 라우터가 같은 메트릭을 쓸 수 있음</li>\n<li>전체 네트워크를 다 수용하기엔 DB가 너무 커짐</li>\n</ul>\n</li>\n<li>\n<p>해결 방안</p>\n<ul>\n<li>거리-벡터 + 경로를 같이 쓰는 하이브리드 형태가 해답이 될 수 있음</li>\n<li>각 라우팅 업데이트가 전체 경로 정보를 담고 있음</li>\n<li>loop는 중간에 감지해 제거</li>\n</ul>\n</li>\n</ul>\n<p><strong>Interconnecting BGP Peers</strong></p>\n<ul>\n<li>BGP는 TCP를 이용해 피어를 연결</li>\n<li>\n<p>장점</p>\n<ul>\n<li>BGP보다 간단해짐</li>\n<li>계속 연결을 유지하고 있기 때문에 주기적 refresh가 필요 없음</li>\n<li>점진적 업데이트 가능</li>\n</ul>\n</li>\n<li>\n<p>단점</p>\n<ul>\n<li>혼잡 제어가 과연 필요할까?</li>\n<li>과부하 걸릴 때 피어 인터랙션은 어떻게 할 것인가?</li>\n</ul>\n</li>\n</ul>\n<p><strong>Hop-by-hop Model</strong></p>\n<ul>\n<li>BGP는 직접 묶여있는 라우터에게 본인이 가진 정보를 광고하는 Hop-by-hop 모델이다.</li>\n</ul>","fields":{"slug":"/posts/til85","tagSlugs":["/tag/til/","/tag/network/"]},"frontmatter":{"date":"2021-01-24T15:30:32","description":"라우팅 기능 및 관련 프로토콜","tags":["til","network"],"title":"컴퓨터 네트워크 강의 - 7장. IP 프로토콜의 이해 (2) 라우팅","socialImage":"/naon.png"}}},"pageContext":{"slug":"/posts/til85"}}}