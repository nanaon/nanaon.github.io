{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/til52","result":{"data":{"markdownRemark":{"id":"01b2658e-da1b-59af-8907-762133c4c07a","html":"<p><a href=\"https://www.youtube.com/watch?v=tPjpcsgxgWc\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">Docker가 무엇인지, 왜 쓰는지 감을 잡는 데에 도움받은 영상</a></p>\n<p><strong>(저같은) 초보자 관점에서 서술합니다.</strong><br>\n<strong>AWS E2C 인스턴스, RDS 생성을 했다는 가정 하에 서술합니다.</strong></p>\n<h3 id=\"docker란\" style=\"position:relative;\"><a href=\"#docker%EB%9E%80\" aria-label=\"docker란 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Docker란</h3>\n<p>도커는 컨테이너 가상화 시스템이다. 소프트웨어적으로 가상의 컴퓨터 시스템을 만드는 것.</p>\n<p>도커는 각 요소(application)가 설치된 모습을 ‘image’라는 형태로 박제해서 저장한다. 박제한 image는 github에 push하는 것과 같은 원리로 dockerhub에 push해서 어디서든 pull해서 작업할 수 있다. 따라서 다른 팀원이 내가 push한 이미지를 끌어와서 본인 작업 공간에서 쓸 수 있다. 팀에서 github을 쓰는 방식과 같다.</p>\n<p>Miniconda로 가상환경을 만들어서 그 안에서 작업했듯이 docker는 ‘container’라는 가상 공간을 만들어서 박제한 image를 이용해 그 가상공간에 각 요소를 설치한다. Miniconda에서도 다른 가상환경을 생성해서 이동하면 그 전 공간에 설치했던 프로그램이 없듯이 도커 컨테이너도 마찬가지다. 각 컨테이너는 독립적으로 돌아간다.</p>\n<h3 id=\"virtual-machinevm과-container-가상화-차이점\" style=\"position:relative;\"><a href=\"#virtual-machinevm%EA%B3%BC-container-%EA%B0%80%EC%83%81%ED%99%94-%EC%B0%A8%EC%9D%B4%EC%A0%90\" aria-label=\"virtual machinevm과 container 가상화 차이점 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual Machine(VM)과 Container 가상화 차이점</h3>\n<p><img src=\"/media/vm-container.png\" alt=\"vm-container-differnece\"></p>\n<h4 id=\"virtual-machine-가상화-특징\" style=\"position:relative;\"><a href=\"#virtual-machine-%EA%B0%80%EC%83%81%ED%99%94-%ED%8A%B9%EC%A7%95\" aria-label=\"virtual machine 가상화 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Virtual Machine 가상화 특징</h4>\n<ul>\n<li>하드웨어 스펙을 정하고 하드웨어 가상화</li>\n<li>가상 하드웨어에 OS 설치</li>\n<li>한 번 쓰는 데에 시간이 오래 걸리는 게 단점</li>\n<li>컴퓨터 한 대로 여러 대를 돌리는 것처럼 쓸 수 있기 때문에 비용 절감 차원에서 사용</li>\n<li>일단 플레이어를 만든 후 테이프/CD를 꽂아서 플레이 하는 것과 같은 원리</li>\n</ul>\n<h4 id=\"container-가상화-특징\" style=\"position:relative;\"><a href=\"#container-%EA%B0%80%EC%83%81%ED%99%94-%ED%8A%B9%EC%A7%95\" aria-label=\"container 가상화 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Container 가상화 특징</h4>\n<ul>\n<li>컨테이너 기반 가상화 서비스</li>\n<li>동일한 OS 상에서 독립된 공간을 생성</li>\n<li>하드웨어 가상화보다 가볍고 빠름</li>\n<li>플레이어를 만들지 않아도 원하는 테이프/CD를 바로 꽂아서 플레이할 수 있는 것과 같은 원리</li>\n</ul>\n<p>VM 방식은 하드웨어 자체를 가상화하기 때문에 각 가상환경마다 OS가 독립적으로 운영된다. CPU가 필요한 OS나 서비스에 그때그때 할당될 수 있으므로 리소스를 효율적으로 사용할 수 있으나, 부팅 시간이 길고 리소스를 많이 차지한다는 단점이 있다.</p>\n<p>Container 가상화 기술은 호스트 서버 하나에 가상 공간을 여러 개 만드는 것으로 VM 보다 가볍고 빠르다. 클라우드 기반 서비스는 용량이 적을수록 비용을 아낄 수 있으므로 용량이 적은 container 가상화가 유리하다.</p>\n<h3 id=\"docker-구조\" style=\"position:relative;\"><a href=\"#docker-%EA%B5%AC%EC%A1%B0\" aria-label=\"docker 구조 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Docker 구조</h3>\n<ul>\n<li><strong>Docker client 와 Server(혹은 Docker engine)</strong><br>\nDocker는 클라이언트가 서버에 명령을 전달하고 서버가 실행시키는 구조다. docker command는 HTTP라는 프로토콜을 이용하는 REST API이다. 예를 들어 docker ps는 docker server의 GET /api-version/containers 으로 HTTP 요청을 보낸 것과 동일한 방식이다. <a href=\"https://senticoding.tistory.com/94\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">출처</a></li>\n<li><strong>Docker 이미지</strong><br>\n위에서 언급했듯 도커는 각 application이 설치된 모습을 ‘image’라는 형태로 박제해서 저장한다. Docker container에서 실행시키고 싶은 application을 docker 이미지로 빌드해서 실행시킨다.</li>\n<li><strong>Docker registries</strong><br>\nDocker registires는 docker 이미지를 저장하는 repository다. 소스 코드를 github에서 관리하듯 docker 이미지를 docker registries에 저장해 관리한다. (예 - Dockerhub)</li>\n<li><strong>Docker containers</strong><br>\nDocker container는 도커 이미지를 실행하는 가상 공간이다. 컨테이너 하나에서 여러 프로세스를 실행할 수 있지만 하나만 실행하는 것을 권장한다.</li>\n</ul>\n<p>Docker는 git처럼 적층형 구조다. 즉, 새로 업데이트 된 부분만 조각조각 쌓인다. 적층형 구조의 장점은 배포 시 기존 서버를 중단하지 않아도 된다는 점이다. CI/CD 서버가 중단되지 않고 실시간으로 배포할 수 있게 해주는 것이 도커다.</p>\n<h3 id=\"docker-사용-흐름\" style=\"position:relative;\"><a href=\"#docker-%EC%82%AC%EC%9A%A9-%ED%9D%90%EB%A6%84\" aria-label=\"docker 사용 흐름 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>Docker 사용 흐름</h3>\n<ol start=\"0\">\n<li><strong>기본 명령어</strong></li>\n</ol>\n<p><code class=\"language-text\">docker ps -a</code> 컨테이너 전체 리스트 보기<br>\n<code class=\"language-text\">docker images -a</code> 이미지 전체 리스트 보기<br>\n<code class=\"language-text\">sudo docker logs 컨테이너명</code> ssh에서 컨테이너 로그 보기<br>\n<code class=\"language-text\">ps -ef | grep python</code> 프로세스 조회. 여기서 pid 확인 가능<br>\n<code class=\"language-text\">sudo kill pid번호</code> EC2 서버 종료</p>\n<p><em>참고) <code class=\"language-text\">-a</code> 명령어는 실행 중인 것, 종료된 것까지 모두 보여준다.</em></p>\n<ol>\n<li><strong>my_setting.py DB HOST 항목에 RDS 주소를 넣어준다.</strong></li>\n</ol>\n<br>\n<ol start=\"2\">\n<li><strong>장고 프로젝트 폴더(메인 폴더)에 Dockerfile 생성</strong></li>\n</ol>\n<p><code class=\"language-text\">vi Dockerfile</code></p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token comment\"># FROM OS 이름</span>\n<span class=\"token comment\"># 기반이 될 이미지 지정</span>\n<span class=\"token comment\"># python 버전 3대 환경의 리눅스 운영체제로 지정</span>\nFROM python:3 \n\n<span class=\"token comment\"># 작업 디렉토리(default)설정</span>\n<span class=\"token comment\"># 홈 디렉토리와 같은 개념</span>\n<span class=\"token comment\"># docker 이미지 파일 시스템 안에 리눅스가 담겨있고 그 안에 있는 디렉토리</span>\nWORKDIR /usr/src/app \n\n<span class=\"token comment\"># Install packages</span>\n<span class=\"token comment\"># 현재 패키지 설치 정보를 도커 이미지에 복사</span>\nCOPY requirements.txt ./ \n<span class=\"token comment\"># 설치 정보를 읽어 들여서 패키지를 설치</span>\n<span class=\"token comment\"># 장고 프로젝트 진행 시 requirements.txt에 설치할 프로그램을 적어두고 한 번에 설치하는 것과 같은 작업</span>\nRUN pip <span class=\"token function\">install</span> -r requirements.txt\n\n<span class=\"token comment\"># Copy all src files</span>\n<span class=\"token comment\">#현재경로에 존재하는 모든 소스파일을 이미지에 복사</span>\nCOPY <span class=\"token builtin class-name\">.</span> <span class=\"token builtin class-name\">.</span> \n\n\n<span class=\"token comment\"># Run the application on the port 8080</span>\n<span class=\"token comment\"># 8000번 포트를 외부에 개방하도록 설정</span>\nEXPOSE <span class=\"token number\">8000</span>   \n\n\n<span class=\"token comment\"># CMD [\"python\", \"./setup.py\", \"runserver\", \"--host=0.0.0.0\", \"-p 8080\"]</span>\n<span class=\"token comment\"># gunicorn을 사용해서 서버를 실행</span>\nCMD <span class=\"token punctuation\">[</span><span class=\"token string\">\"gunicorn\"</span>, <span class=\"token string\">\"--bind\"</span>, <span class=\"token string\">\"0.0.0.0:8000\"</span>, <span class=\"token string\">\"DB이름.wsgi:application\"</span><span class=\"token punctuation\">]</span>  </code></pre></div>\n<p><em>참고) gunicorn은 서버를 백그라운드 프로세스로 구동하기 위해 사용한다. <code class=\"language-text\">python manage.py runserver</code> 명령어는 개발용이므로 실제 배포에는 사용하지 않는다.</em></p>\n<br>\n<ol start=\"3\">\n<li><strong>이미지 빌드하기</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">docker build <span class=\"token operator\">-</span>t 도커허브계정명<span class=\"token operator\">/</span>프로젝트명<span class=\"token punctuation\">:</span>버전 <span class=\"token punctuation\">.</span></code></pre></div>\n<p><em>예) <code class=\"language-text\">docker build -t account/project:0.1.0 .</code></em></p>\n<p>이 명령어를 실행하면 python과 requirements.txt에 저장한 application이 자동으로 설치된다.</p>\n<br>\n<ol start=\"4\">\n<li><strong>dockerhub에 빌드한 이미지를 push하기</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\"><span class=\"token comment\"># 도커 허브 계정 정보를 입력하고 로그인</span>\ndocker login\n\n<span class=\"token comment\"># 도커 허브에 push</span>\n<span class=\"token comment\"># 위에서 빌드한 버전과 동일하게 써준다.</span>\ndocker push 도커허브아이디<span class=\"token operator\">/</span>프로젝트명<span class=\"token punctuation\">:</span>버전`</code></pre></div>\n<br>\n<ol start=\"5\">\n<li><strong>ssh 접속</strong></li>\n</ol>\n<p>.pem 파일이 있는 곳에서 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"python\"><pre class=\"language-python\"><code class=\"language-python\">ssh <span class=\"token operator\">-</span>i 키이름<span class=\"token punctuation\">.</span>pem ubuntu@퍼블릭IP</code></pre></div>\n<p>퍼블릭 IP 주소는 AWS EC2 인스턴스 생성 후 확인할 수 있다.</p>\n<br>\n<ol start=\"6\">\n<li><strong>docker 설치</strong></li>\n</ol>\n<p>별도 OS이므로 도커를 다시 설치해준다. 아래 명령어를 한 줄씩 붙여넣어 실행한다.</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> apt-transport-https ca-certificates <span class=\"token function\">curl</span> software-properties-common\n<span class=\"token function\">curl</span> -fsSL https://download.docker.com/linux/ubuntu/gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -\n<span class=\"token function\">sudo</span> add-apt-repository <span class=\"token string\">\"deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable\"</span>\n<span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> update\n<span class=\"token function\">apt-cache</span> policy docker-ce</code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> <span class=\"token function\">apt</span> <span class=\"token function\">install</span> docker-ce</code></pre></div>\n<p><code class=\"language-text\">docker</code> 명령어를 입력해 정상 설치되었는지 확인한다.</p>\n<br>\n<ol start=\"7\">\n<li><strong>dockerhub에서 pull 해오기</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> docker pull nanaon/zigbang:0.1.0</code></pre></div>\n<p><em>참고) 우분투 OS이므로 도커 명령어를 입력할 때 앞에 꼭 <code class=\"language-text\">sudo</code>를 붙여야 한다.</em></p>\n<br>\n<ol start=\"8\">\n<li><strong>빌드한 이미지 실행</strong></li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">sudo</span> docker run --name 컨테이너명 -d -p <span class=\"token number\">8000</span>:8000 도커허브계정명/프로젝트명:버전</code></pre></div>\n<p>컨테이너 이름 지정은 필수가 아니다. 지정하지 않아도 docker에서 두 단어를 조합해 컨테이너 이름을 만들어준다. 단, 한 번 사용한 컨테이너 이름은 재사용할 수 없다.</p>\n<p><code class=\"language-text\">-d</code>는 컨테이너를 백그라운드로 실행하는 옵션이다.</p>\n<p><code class=\"language-text\">-p 8000:8000</code>은 port forwarding으로, 내 로컬 8000 포트와 도커 8000 포트를 매칭해준다.</p>\n<p>만약 코드에 수정사항이 있다면 이미지 빌드 단계부터 다시 실행한다. 버전은 그때마다 올려주어야 한다. (예 - 0.1.0 -> 0.1.1)</p>","fields":{"slug":"/posts/til52","tagSlugs":["/tag/til/","/tag/docker/","/tag/aws/","/tag/rds/","/tag/deploy/"]},"frontmatter":{"date":"2020-07-16T15:30:32","description":"Docker를 이용해 프로젝트 배포하기","tags":["til","docker","aws","rds","deploy"],"title":"Docker 기본 개념과 사용법","socialImage":"/naon.png"}}},"pageContext":{"slug":"/posts/til52"}}}